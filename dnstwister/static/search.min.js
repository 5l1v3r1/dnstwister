!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.jsonpipe=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
/* eslint no-param-reassign:0 */
'use strict';

var xhr = _dereq_('./net/xhr'),
    utils = _dereq_('./utils.js'),
    Parser = _dereq_('./parsers/json-chunk'),
    /**
     * @param {String} url A string containing the URL to which the request is sent.
     * @param {Object} url A set of key/value pairs that configure the Ajax request.
     * @return {XMLHttpRequest} The XMLHttpRequest object for this request.
     * @method ajax
     */
    ajax = function(url, options) {
        // Do all prerequisite checks
        if (!url) {
            return undefined;
        }

        // Set arguments if first argument is not string
        if (!utils.isString(url)) {
            options = url;
            url = options.url;
        }

        // Check if all mandatory attributes are present
        if (!url ||
            !options ||
            !(options.success || options.error || options.complete)) {
            return undefined;
        }

        // Init the parser
        var parser = new Parser(options);

        // Assign onChunk to options with parse function, binded to the parser object
        options.onChunk = parser.parse.bind(parser);

        return xhr.send(url, options);
    };

module.exports = {
    flow: ajax
};

},{"./net/xhr":2,"./parsers/json-chunk":3,"./utils.js":4}],2:[function(_dereq_,module,exports){
'use strict';

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

function parseHeader(str) {
    var lines = str.split(/\r?\n/);
    var fields = {};
    var index;
    var line;
    var field;
    var val;

    lines.pop(); // trailing CRLF

    for (var i = 0, len = lines.length; i < len; ++i) {
        line = lines[i];
        index = line.indexOf(':');
        field = line.slice(0, index).toLowerCase();
        val = trim(line.slice(index + 1));
        fields[field] = val;
    }

    return fields;
}

function send(url, options) {
    if (!url || !options) {
        return undefined;
    }

    var xhr = new XMLHttpRequest(),
        state = {
            UNSENT: 0,
            OPENED: 1,
            HEADERS_RECEIVED: 2,
            LOADING: 3,
            DONE: 4
        },
        noop = function() {},
        method = (options.method || '').toUpperCase(),
        headers = options.headers,
        onChunk = options.onChunk || noop,
        onHeaders = options.onHeaders || noop,
        errorFn = options.error || noop,
        completeFn = options.complete || noop,
        addContentHeader = method === 'POST',
        isChunked = false,
        timer;

    xhr.open(method || 'GET', url, true);

    // Attach onreadystatechange
    xhr.onreadystatechange = function() {
        var encoding,
            chromeObj,
            loadTimes,
            chromeSpdy;
        if (xhr.readyState === state.HEADERS_RECEIVED) {
            encoding = xhr.getResponseHeader('Transfer-Encoding') || '';
            encoding = encoding.toLowerCase();
            isChunked = encoding.indexOf('chunked') > -1 ||
                        encoding.indexOf('identity') > -1; // fix for Safari
            if (!isChunked) {
                // SPDY inherently uses chunked transfer and does not define a header.
                // Firefox provides a synthetic header which can be used instead.
                // For Chrome, a non-standard JS function must be used to determine if
                // the primary document was loaded with SPDY.  If the primary document
                // was loaded with SPDY, then most likely the XHR will be as well.
                chromeObj = window.chrome;
                loadTimes = chromeObj && chromeObj.loadTimes && chromeObj.loadTimes();
                chromeSpdy = loadTimes && loadTimes.wasFetchedViaSpdy;
                isChunked = !!(xhr.getResponseHeader('X-Firefox-Spdy') || chromeSpdy);
            }
            onHeaders(xhr.statusText, parseHeader(xhr.getAllResponseHeaders()));
        } else if (xhr.readyState === state.LOADING) {
            if (isChunked && xhr.responseText) {
                onChunk(xhr.responseText);
            }
        } else if (xhr.readyState === state.DONE) {
            // clear timeout first
            clearTimeout(timer);
            // Check for error first
            if (xhr.status < 200 || xhr.status > 299) {
                errorFn(xhr.statusText);
            } else {
                onChunk(xhr.responseText, true);
            }
            // Call complete at the end
            completeFn(xhr.statusText);
        }
    };

    // Add headers
    if (headers) {
        for (var key in headers) { // eslint-disable-line guard-for-in
            xhr.setRequestHeader(key, headers[key]);
            if (key.toLowerCase() === 'content-type') {
                addContentHeader = false;
            }
        }
    }
    if (addContentHeader) {
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    }

    // Add timeout
    if (options.timeout) {
        timer = setTimeout(function() {
            xhr.abort();
            clearTimeout(timer);
        }, options.timeout);
    }

    // Set credentials
    if (options.hasOwnProperty("withCredentials")) {
        xhr.withCredentials = options.withCredentials;
    } else {
        xhr.withCredentials = true;
    }

    xhr.send(options.data);

    return xhr;
}

module.exports = {
    send: send
};

},{}],3:[function(_dereq_,module,exports){
'use strict';

var utils = _dereq_('../utils.js');

function Parser(options) {
    this.offset = 0;
    this.token = options.delimiter || '\n\n';
    this.success = options.success;
    this.error = options.error;
}

Parser.prototype.parse = function(text, finalChunk) {
    var chunk = text.substring(this.offset),
        start = 0,
        finish = chunk.indexOf(this.token, start),
        subChunk;

    if (finish === 0) { // The delimiter is at the beginning so move the start
        start = this.token.length;
    }

    // Re-assign finish to the next token
    finish = chunk.indexOf(this.token, start);

    while (finish > -1) {
        subChunk = chunk.substring(start, finish);
        if (subChunk) {
            utils.parse(subChunk, this.success, this.error);
        }
        start = finish + this.token.length; // move the start
        finish = chunk.indexOf(this.token, start); // Re-assign finish to the next token
    }
    this.offset += start; // move the offset

    // Get the remaning chunk
    chunk = text.substring(this.offset);
    // If final chunk and still unprocessed chunk and no delimiter, then execute the full chunk
    if (finalChunk && chunk && finish === -1) {
        utils.parse(chunk, this.success, this.error);
    }
};

module.exports = Parser;


},{"../utils.js":4}],4:[function(_dereq_,module,exports){
'use strict';

function isString(str) {
    return Object.prototype.toString.call(str) === '[object String]';
}

function isFunction(fn) {
    return Object.prototype.toString.call(fn) === '[object Function]';
}

// Do the eval trick, since JSON object not present
function customParse(chunk) {
    if (!chunk || !/^[\{|\[].*[\}|\]]$/.test(chunk)) {
        throw new Error('parseerror');
    }
    return eval('(' + chunk + ')'); // eslint-disable-line no-eval
}

function parse(chunk, successCb, errorCb) {
    var jsonObj;
    try {
        jsonObj = typeof JSON !== 'undefined' ? JSON.parse(chunk) : customParse(chunk);
    } catch (ex) {
        if (isFunction(errorCb)) {
            errorCb('parsererror');
        }
        return;
    }
    // No parse error proceed to success
    if (jsonObj && isFunction(successCb)) {
        successCb(jsonObj);
    }
}

module.exports = {
    isString: isString,
    isFunction: isFunction,
    parse: parse
};

},{}]},{},[1])
(1)
});
/* global Velocity */
var ui = (function () {
  var reportShown = false

  var anchorElem = function (innerHtml, href, className) {
    var elem = document.createElement('a')
    elem.href = href
    elem.className = className || ''
    elem.insertAdjacentHTML('afterbegin', innerHtml)
    return elem
  }

  var updatedProgress = function (checkedCount, resolvedCount) {
    var checkedCountElem = document.getElementById('checked_count')
    var resolvedCountElem = document.getElementById('resolved_count')
    var reportTableElem = document.getElementById('main_report')

    if (checkedCount > 0) {
      checkedCountElem.innerHTML = checkedCount
    }

    if (resolvedCount > 0) {
      resolvedCountElem.innerHTML = resolvedCount
      if (reportShown === false) {
        reportShown = true
        reportTableElem.style.display = 'table'
      }
    }
  }

  var startProgressDots = function () {
    var searchDotsElem = document.getElementById('search_dots')

    return setInterval(function () {
      var dotsCount = (searchDotsElem.firstChild || []).length
      var nextDotsCount = (dotsCount + 1) % 4

      var newDots = ''
      for (var i = 0; i < nextDotsCount; i++) {
        newDots += '.'
      }
      searchDotsElem.innerHTML = newDots
    }, 350)
  }

  var markProgressAsDone = function () {
    var progressElem = document.getElementsByClassName('search_progress')[0]
    progressElem.innerHTML = 'Done!'

    Velocity(document.getElementsByClassName('wip_text'), 'fadeOut', { duration: 500, delay: 250 })
    Velocity(progressElem, 'slideUp', { duration: 500, delay: 1500 })
    Velocity(document.getElementsByClassName('search_result'), { 'font-size': '150%' }, { duration: 500, delay: 1500 })
  }

  var reportRowElem = function (domain, punyCodedDomain, encodedDomain, ipText) {
    var rowElem = document.createElement('tr')
    var domainCellElem = document.createElement('td')
    var ipCellElem = document.createElement('td')
    var toolsCellElem = document.createElement('td')

    var domainText = domain
    if (domain !== punyCodedDomain) {
      domainText += ' (' + punyCodedDomain + ')'
    }
    domainCellElem.appendChild(document.createTextNode(domainText))
    ipCellElem.appendChild(document.createTextNode(ipText))
    toolsCellElem.className = 'tools'

    toolsCellElem.appendChild(
      anchorElem('analyse', '/analyse/' + encodedDomain)
    )
    toolsCellElem.appendChild(
      anchorElem('&#128270;', '/search?ed=' + encodedDomain, 'deep-search')
    )

    rowElem.appendChild(domainCellElem)
    rowElem.appendChild(ipCellElem)
    rowElem.appendChild(toolsCellElem)
    rowElem.className = 'domain-row resolved'

    return rowElem
  }

  var addResolvedRow = function (reportElem, domain, punyCodedDomain, encodedDomain, ip) {
    reportElem.appendChild(
      reportRowElem(domain, punyCodedDomain, encodedDomain, ip)
    )
  }

  return {
    updatedProgress: updatedProgress,
    startProgressDots: startProgressDots,
    markProgressAsDone: markProgressAsDone,
    addResolvedRow: addResolvedRow
  }
})()

/* globals jsonpipe, ui, XMLHttpRequest */
var search = (function () {
  var resolve = function (punyCodedDomain, callback) {
    var request = new XMLHttpRequest()
    var url = 'https://dnstwister.report/api/ip2?pd=' + punyCodedDomain
    request.open('GET', url)
    request.send()
    request.onreadystatechange = (e) => {
      if (request.readyState === 4) {
        if (request.status === 200) {
          var responseText = request.responseText
          var response = JSON.parse(responseText)
          if (response.error === false) {
            callback(response.ip)
          } else {
            callback(null)
          }
        } else {
          callback(null)
        }
      }
    }
  }

  var runSearch = function (encodedDomain) {
    var seen = []
    var checkedCount = 0
    var resolvedCount = 0
    var resolveQueue = []
    var startedResolving = false
    var allFound = false
    var cleaningUp = false

    var reportElem = document.getElementById('report_target')

    var progressTimer = ui.startProgressDots()

    var resolveNext = function (queue) {
      var data = queue.pop()
      if (data === undefined) {
        if (allFound === true) {
          if (cleaningUp === false) {
            cleaningUp = true
            clearInterval(progressTimer)
            ui.markProgressAsDone()
          }
          return
        } else {
          // If queue exhausted, wait for more.
          setTimeout(function () {
            resolveNext(queue)
          }, 1000)
          return
        }
      }

      if (seen.indexOf(data.d) !== -1) {
        resolveNext(queue)
        return
      }

      seen.push(data.d)
      resolve(data.pd, function (ip) {
        checkedCount += 1
        ui.updatedProgress(checkedCount, resolvedCount)

        if (ip === null) {
          resolveNext(queue)
          return
        } else if (ip === false) {
          resolveNext(queue)
          return
        }

        resolvedCount += 1
        ui.updatedProgress(checkedCount, resolvedCount)
        ui.addResolvedRow(reportElem, data.d, data.pd, data.ed, ip)
        resolveNext(queue)
      })
    }

    jsonpipe.flow('/api/fuzz_chunked/' + encodedDomain, {
      'success': function (data) {
        resolveQueue.push(data)

        if (startedResolving !== true) {
          startedResolving = true
          for (var i = 0; i < 20; i++) {
            setTimeout(function () {
              resolveNext(resolveQueue)
            }, 500)
          }
        }
      },
      'complete': function () {
        allFound = true
      }
    })
  }

  return {
    run: runSearch
  }
})()
